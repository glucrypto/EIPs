---
eip: 4973
title: Agreeable Tokens
description: An interface for minimally transferable agreements binding to consenting accounts.
author: Tim Daubensch√ºtz (@TimDaub), Raphael Roullet (@ra-phael)
discussions-to: https://ethereum-magicians.org/t/eip-4973-non-transferrable-non-fungible-tokens-soulbound-tokens-or-badges/8825
status: Review
type: Standards Track
category: ERC
created: 2022-04-01
requires: 165, 712, 721, 1271, 2098
---

## Abstract

Proposes a standard API from agreeable tokens (AT) within smart contracts. An agreeable token is a bilateral opt-in token bound to consenting accounts. ATs don't implement a canonical interface for transfers. This EIP defines basic functionality to mint, assign, revoke and track ATs.

## Motivation

There exists a need for a standard that contracts can use to understand, track and create an agreement between two parties. Special care was taken to mandate user's right to enter agreements consensually via a signature and right to exit signal an agreement at any time. With a standard approach to agreements we can facilitate respect of these rights across communities and projects.

Popular contracts implicitly implement agreement interactions today by modifying other standards to disallow transfers. While this method works for simple agreements, as those interactions grow in complexity, commonality is needed to ensure user-agents and applications are not left disconnected and siloed from each other.

Specifically, a principled standardization helps interoperability and improves on-chain data indexing.

The purpose of this document is to make ATs a reality on Ethereum by creating consensus around a maximally backward-compatible but otherwise minimal interface definition.

## Specification

### Solidity Interface

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

ATs _must_ implement the interfaces:

- [EIP-165](./eip-165.md)'s `ERC165` (`0x01ffc9a7`)
- [EIP-721](./eip-721.md)'s `ERC721Metadata` (`0x5b5e139f`)

ATs _must not_ implement the interfaces:

- [EIP-721](./eip-721.md)'s `ERC721` (`0x80ac58cd`)

An AT receiver must be able to always call `function unequip(address _tokenId)` to take their AT off-chain.

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.6;

/// @title Agreeable tokens
/// @dev See https://eips.ethereum.org/EIPS/eip-4973
/// Note: the ERC-165 identifier for this interface is 0x8d7bac72
interface IERC4973 {
  /// @dev This emits when ownership of any AT changes by any mechanism.
  ///  This event emits when ATs are given or equipped and unequipped
  ///  (`to` == 0).
  event Transfer(
    address indexed from,
    address indexed to,
    uint256 indexed tokenId
  );
  /// @notice Count all ATs assigned to an owner
  /// @dev ATs assigned to the zero address are considered invalid, and this
  ///  function throws for queries about the zero address.
  /// @param owner An address for whom to query the balance
  /// @return The number of ATs owned by `address owner`, possibly zero
  function balanceOf(address owner) external view returns (uint256);
  /// @notice Find the address bound to an ERC4973 agreeable token
  /// @dev ATs assigned to zero address are considered invalid, and queries
  ///  about them do throw.
  /// @param tokenId The identifier for an AT.
  /// @return The address of the owner bound to the AT.
  function ownerOf(uint256 tokenId) external view returns (address);
  /// @notice Removes the `uint256 tokenId` from an account. At any time, an
  ///  AT receiver must be able to disassociate themselves from an AT
  ///  publicly through calling this function. After successfully executing this
  ///  function, given the parameters for calling `function give` or
  ///  `function take` a token must be re-equipable.
  /// @dev Must emit a `event Transfer` with the `address to` field pointing to
  ///  the zero address.
  /// @param tokenId The identifier for an AT.
  function unequip(uint256 tokenId) external;
  /// @notice Creates and transfers the ownership of an AT from the
  ///  transaction's `msg.sender` to `address to`.
  /// @dev Throws unless `bytes signature` represents an EIP-2098 Compact
  ///  Signature of the EIP-712 structured data hash
  ///  `Agreement(address active,address passive,string tokenURI)` expressing
  ///  `address to`'s explicit agreement to be publicly associated with
  ///  `msg.sender` and `string tokenURI`. A unique `uint256 tokenId` must be
  ///  generated by type-casting the `bytes32` EIP-712 structured data hash to a
  ///  `uint256`. If `bytes signature` is empty or `address to` is a contract,
  ///  an EIP-1271-compatible call to `function isValidSignatureNow(...)` must
  ///  be made to `address to`. A successful execution must result in the
  ///  `event Transfer(msg.sender, to, tokenId)`. Once an AT exists as an
  ///  `uint256 tokenId` in the contract, `function give(...)` must throw.
  /// @param to The receiver of the AT.
  /// @param uri A distinct Uniform Resource Identifier (URI) for a given AT.
  /// @param signature A EIP-2098-compatible Compact Signature of the EIP-712
  ///  structured data hash
  ///  `Agreement(address active,address passive,string tokenURI)` signed by
  ///  `address to`.
  /// @return A unique `uint256 tokenId` generated by type-casting the `bytes32`
  ///  EIP-712 structured data hash to a `uint256`.
  function give(
    address to,
    string calldata uri,
    bytes calldata signature
  ) external returns (uint256);
  /// @notice Creates and transfers the ownership of an AT from an
  /// `address from` to the transaction's `msg.sender`.
  /// @dev Throws unless `bytes signature` represents an EIP-2098 Compact
  ///  Signature of the EIP-712 structured data hash
  ///  `Agreement(address active,address passive,string tokenURI)` expressing
  ///  `address from`'s explicit agreement to be publicly associated with
  ///  `msg.sender` and `string tokenURI`. A unique `uint256 tokenId` must be
  ///  generated by type-casting the `bytes32` EIP-712 structured data hash to a
  ///  `uint256`. If `bytes signature` is empty or `address from` is a contract,
  ///  an EIP-1271-compatible call to `function isValidSignatureNow(...)` must
  ///  be made to `address from`. A successful execution must result in the
  ///  emission of an `event Transfer(from, msg.sender, tokenId)`. Once an AT
  ///  exists as an `uint256 tokenId` in the contract, `function take(...)` must
  ///  throw.
  /// @param from The origin of the AT.
  /// @param uri A distinct Uniform Resource Identifier (URI) for a given AT.
  /// @param signature A EIP-2098-compatible Compact Signature of the EIP-712
  ///  structured data hash
  ///  `Agreement(address active,address passive,string tokenURI)` signed by
  ///  `address from`.
  /// @return A unique `uint256 tokenId` generated by type-casting the `bytes32`
  ///  EIP-712 structured data hash to a `uint256`.
  function take(
    address from,
    string calldata uri,
    bytes calldata signature
  ) external returns (uint256);
}
```

See [EIP-721](./eip-721.md) for a definition of its metadata JSON Schema.

### [EIP-712](./eip-712.md) Typed Structured Data Hashing and [EIP-2098](./eip-2098) Compact Signature Creation

To invoke `function give(...)` and `function take(...)` an [EIP-2098](./eip-2098.md) compact signature must be created using [EIP-712](./eip-712.md). A tested reference implementation is attached at [../assets/eip-4973/generateSignature.mjs](../assets/eip-4973/generateSignature.mjs) and [../assets/eip-4973/generateSignature_test.mjs](../assets/eip-4973/generateSignature_test.mjs).

## Rationale

### Interface

ATs shall be maximally backward-compatible but still only expose a minimal and simple to implement interface definition.

As [EIP-721](./eip-721.md) tokens have seen widespread adoption with wallet providers and marketplaces, using its `ERC721Metadata` interface with [EIP-165](./eip-165.md) for feature-detection potentially allows implementers to support ATs out of the box.

If an implementer of [EIP-721](./eip-721.md) properly built [EIP-165](./eip-165.md)'s `function supportsInterface(bytes4 interfaceID)` function, already by recognizing that [EIP-721](./eip-721.md)'s track and transfer interface component with the identifier `0x80ac58cd` is not implemented, transferring of a token should not be suggested as a user interface option.

Still, since ATs support [EIP-721](./eip-721.md)'s `ERC721Metadata` extension, wallets and marketplaces should display an agreeable token with no changes needed.

Although other implementations of agreeable tokens are possible, e.g., by having all transfer functions revert, ATs are superior as it supports feature detection through [EIP-165](./eip-165.md).

We expose `function unequip(address _tokenId)` and require it to be callable at any time by an AT's owner as it ensures an owner's right to publicly disassociate themselves from what has been issued towards their account.

### "Agreeable" Naming Choice

The "Agreeable" name was chosen based on the culmination of discussion around the ERC chiefly to remove semantic debate and ambiguity present in other potential naming candidates such as, account-bound tokens, soul-bound tokens or name-bound tokens.

### Exception handling

Given the non-transferable between accounts property of ATs, if a user's keys to an account or a contract get compromised or rotated, a user may lose the ability to associate themselves with the token. In some cases, this can be the desired effect. Therefore, AT implementers should build re-issuance and revocation processes to enable recourse. We recommend implementing strictly decentralized, permissionless, and censorship-resistant re-issuance processes.

But this document is deliberately abstaining from offering a standardized form of exception handling in cases where user keys are compromised or rotated.

In cases where implementers want to make agreeable tokens shareable among different accounts, e.g., to avoid losing access when keys get compromised, we suggest issuing the agreeable token towards a contract's account that implements a multi-signature functionality.

### Provenance Indexing

ATs can be indexed by tracking the emission of `event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)`. As with [EIP-721](./eip-721.md), transfers between two accounts are represented by `address from` and `address to` being non-zero addresses. Unequipping a token is represented through emitting a transfer with `address to` being set to the zero address. Mint operations where `address from` is set to zero don't exist. To avoid being spoofed by maliciously-implemented `event Transfer` emitting contracts, an indexer should ensure that the transaction's sender is equal to `event Transfer`'s `from` value.

## Backwards Compatibility

We have adopted the [EIP-165](./eip-165.md) and `ERC721Metadata` functions purposefully to create a high degree of backward compatibility with [EIP-721](./eip-721.md). We have deliberately used [EIP-721](./eip-721.md) terminology such as `function ownerOf(...)`, `function balanceOf(...)` to minimize the effort of familiarization for AT implementers already familiar with, e.g., [EIP-20](./eip-20.md) or [EIP-721](./eip-721.md). For indexers, we've re-used the widely-implemented `event Transfer` event signature.

## Reference Implementation

You can find an implementation of this standard in [../assets/eip-4973](../assets/eip-4973/ERC-4973.sol).

## Security Considerations

There are no security considerations related directly to the implementation of this standard.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
